### AOF

#### AOF缓冲区文件写入硬盘策略

| 配置项   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| always   | 每次命令处理完成后同步写入硬盘：命令写入aof_buf后系统调用fsync写入到aof文件后线程返回 |
| everysec | 每隔一段时间将缓冲区中数据写入硬盘：命令写入aof_buf后调用write操作写入内核缓冲区，线程返回。fsync由专门的线程每隔一段时间同步到aof文件中（实际上丢失两秒数据） |
| no       | 由操作系统控制何时写入硬盘： 命令写入aof_buf后调用write操作，不对aof做fsync操作，由操作系统负责将缓冲区中的数据写入硬盘 |



### AOF重写

多条命令合并，旧的aof文件中del等删除修改操作无效 

#### 1、重写时机

1. 手动触发：调用bgrewriteaof

2. 自动触发： 配置文件中配置的命令

   auto-aof-rewrite-percentage 100 
   auto-aof-rewrite-min-size 64mb   重写前aof文件大于64M

#### 2、重写流程

1. 如果当前进程正在进行AOF重写， 请求不执行，如果正在执行bgsave（创建一个子进程，执行RDB），重写命令延迟到bgsive完成后再执行
2. 父进程调用fork创建子进程
3. fork完成后，父进程继续响应其他命令，继续执行的命令依然写入aof_buf, 并根据写硬盘策略写入到aof文件中
4. 之后执行的命令也写入到aof重写缓冲区中，因为子进程使用的写时复制，只有之前的命令。
5. 子进程根据内存快照，按照合并规则写入到新的AOF文件中，每次批量写入硬盘数据大小由aof_rewrite_incremental_fsync控制默认32M
6. 新aof文件写入完成后，子进程发送给父进程信号，父进程更新aof统计信息
7. 父进程把aof重写缓冲区的数据写入到新的aof文件中
8. 使用新的aof文件替换老文件

#### AOF追加阻塞

everysec模式下的aof

- 主线程负责将数据写入AOF缓冲区，everysec 配置表名主线程每秒执行一次同步磁盘操作，并记录同步时间， 下一次同步开始之前对比时间是否超过两秒，

  两秒内不执行，两秒后执行刷盘。

#### 3、子进程造成的问题

a、fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

b、fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。

#### 4、AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？

AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。









