#### RDB：内存快照

#### 执行时机

1. save命令：主线程中执行
2. bgsave：创建子进程执行





### 建议配置的持久化机

- 设置间隔时间的RDB快照， 在间隔之间使用AOF
- 避免了频繁调用RDB对redis性能损耗， 
- 避免了AOF重写

### 我曾碰到过这么一个场景：我们使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB，我们使用了 RDB 做持久化保证。当时 Redis 的运行负载以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。你觉得，在这个场景下，用 RDB 做持久化有什么风险吗？你能帮着一起分析分析吗？

**从子进程开销，内存开销，cpu开销考虑，硬盘对AOF/RDB影响，毕竟redis追求的是高性能**

a、内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，“写实复制”会重新分配整个实例80%的内存副本，大约需要重新分配1.6GB内存空间，这样整个系统的内存使用接近饱和，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。

b、CPU资源风险：虽然子进程在做RDB持久化，但生成RDB快照过程会消耗大量的CPU资源，虽然Redis处理处理请求是单线程的，但Redis Server还有其他线程在后台工作，例如AOF每秒刷盘、异步关闭文件描述符这些操作。由于机器只有2核CPU，这也就意味着父进程占用了超过一半的CPU资源，此时子进程做RDB持久化，可能会产生CPU竞争，导致的结果就是父进程处理请求延迟增大，子进程生成RDB快照的时间也会变长，整个Redis Server性能下降。

c、另外，可以再延伸一下，老师的问题没有提到Redis进程是否绑定了CPU，如果绑定了CPU，那么子进程会继承父进程的CPU亲和性属性，子进程必然会与父进程争夺同一个CPU资源，整个Redis Server的性能必然会受到影响！所以如果Redis需要开启定时RDB和AOF重写，进程一定不要绑定CPU。



### 产生性能损耗原因

- fork系统调用耗时，子进程复制父进程资源， 页表越大越耗时

- 子进程开销监控和优化： 子进程复制内核缓冲区数据分批写入到磁盘，计算文件大小消耗CPU，内存消耗主要在fork，和fork后对原有数据如果有修改操作

  fork的写时复制就会复制父进程映射的屋里内存的数据，内存使用量上升。AOF重写也会使用aof重写缓冲区。

  

#### 优化：

- redis不要绑定cpu，以免造成父子进程之间cpu竞争。
- 不要开启大页表选项，每页太大fork过程变慢 ，写时复制也会变慢
- 多实例在单台机器，分盘存储不同实例的持久化文件

### 常用查询阻塞消耗用时命令

- infor stats：lastest_fork_usec单位毫秒
- info persistence : aof_delayed_fsync

