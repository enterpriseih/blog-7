### 进程

- 资源管理的基本单位
- 



### 线程

- cpu调度的基本单位，调度cpu执行指令
- 线程执行遇到系统调度会产生上下文切换
- 线程的创建和销魂动作耗时



### 协程

- 轻量级的用户线程
- 由于工作在用户态不会产生上下文切换。





需要澄清一下整个 io 过程：

- io 与系统调用不能混淆，一个 io 过程可能包括多次系统调用。
- （经过一个系统调用发现文件描述符还未可用而）阻塞的 io 首先会导致 G 的挂起，此时 G 与 M 分离，且不在任何 P 的运行队列中，当前的 P 会调度下一个 G，这个阶段不涉及新线程的创建。
- 被 io 挂起的 G 由网络轮询器维护，直到文件描述符可用。
- 网络轮询器既会被（在独立线程中的）系统监控 Goroutine 触发，也会被其他各个活跃线程上的 Goroutine 触发。
- 当文件描述符可用时，G 会重新加入到原来的 P 中等待被调度。
- 当 G 被重新调度时，会重新发起读/写系统调用。
- 当 G 进行系统调用的时候，对应的 M 和 P 也阻塞在系统调用，并不会立刻发生抢占，只有当这个阻塞持续时间过长（10 ms）时，才会将 P（及之上的其他 G）抢占并分配到空闲的 M 上，此时如果没有空闲的，才会创建新的线程。

通过以上过程可见，密集的 io 通常并不会产生过多的线程。





在目前的运行时中，线程、处理器、网络轮询器、运行队列、全局内存分配器状态、内存分配缓存和垃圾收集器都是全局资源。运行时没有保证本地化，也不清楚系统的拓扑结构，部分结构可以提供一定的局部性，但是从全局来看没有这种保证。